#include <vcpkg/base/downloads.h>
#include <vcpkg/base/system.print.h>

#include <vcpkg/commands.cve-check.h>
#include <vcpkg/configure-environment.h>
#include <vcpkg/dependencies.h>
#include <vcpkg/globalstate.h>
#include <vcpkg/help.h>
#include <vcpkg/paragraphs.h>
#include <vcpkg/portfileprovider.h>
#include <vcpkg/sourceparagraph.h>
#include <vcpkg/vcpkgcmdarguments.h>
#include <vcpkg/vcpkglib.h>
#include <vcpkg/versions.h>

#include <set>

using namespace vcpkg;
using vcpkg::PortFileProvider::PathsPortFileProvider;

namespace
{
    std::vector<std::string> splitCpe(std::string s, char delimiter = ':')
    {
        size_t pos_start = 0, pos_end;

        std::string token;
        std::vector<std::string> res;

        while ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)
        {
            token = s.substr(pos_start, pos_end - pos_start);
            pos_start = pos_end + 1;
            res.push_back(token);
        }

        res.push_back(s.substr(pos_start));
        return res;
    }

    void do_print_json(std::vector<const vcpkg::SourceControlFile*> source_control_files)
    {
        Json::Object obj;
        for (const SourceControlFile* scf : source_control_files)
        {
            auto& source_paragraph = scf->core_paragraph;
            Json::Object& library_obj = obj.insert(source_paragraph->name, Json::Object());
            library_obj.insert("package_name", Json::Value::string(source_paragraph->name));
            library_obj.insert("version", Json::Value::string(source_paragraph->raw_version));
            library_obj.insert("port_version", Json::Value::integer(source_paragraph->port_version));
            Json::Array& desc = library_obj.insert("description", Json::Array());
            for (const auto& line : source_paragraph->description)
            {
                desc.push_back(Json::Value::string(line));
            }
        }

        print2(Json::stringify(obj, Json::JsonStyle{}));
    }
    constexpr const int s_name_and_ver_columns = 41;
    void do_print(const SourceParagraph& source_paragraph, bool full_desc)
    {
        auto full_version = Version(source_paragraph.raw_version, source_paragraph.port_version).to_string();
        if (full_desc)
        {
            vcpkg::printf("%-20s %-16s %s\n",
                          source_paragraph.name,
                          full_version,
                          Strings::join("\n    ", source_paragraph.description));
        }
        else
        {
            std::string description;
            if (!source_paragraph.description.empty())
            {
                description = source_paragraph.description[0];
            }
            static constexpr const int name_columns = 24;
            size_t used_columns = std::max<size_t>(source_paragraph.name.size(), name_columns) + 1;
            int ver_size = std::max(0, s_name_and_ver_columns - static_cast<int>(used_columns));
            used_columns += std::max<size_t>(full_version.size(), ver_size) + 1;
            size_t description_size = used_columns < (119 - 40) ? 119 - used_columns : 40;

            vcpkg::printf("%-*s %-*s %s\n",
                          name_columns,
                          source_paragraph.name,
                          ver_size,
                          full_version,
                          vcpkg::shorten_text(description, description_size));
        }
    }

    void do_print(const std::string& name, const FeatureParagraph& feature_paragraph, bool full_desc)
    {
        auto full_feature_name = Strings::concat(name, "[", feature_paragraph.name, "]");
        if (full_desc)
        {
            vcpkg::printf("%-37s %s\n", full_feature_name, Strings::join("\n   ", feature_paragraph.description));
        }
        else
        {
            std::string description;
            if (!feature_paragraph.description.empty())
            {
                description = feature_paragraph.description[0];
            }
            size_t desc_length =
                119 - std::min<size_t>(60, 1 + std::max<size_t>(s_name_and_ver_columns, full_feature_name.size()));
            vcpkg::printf(
                "%-*s %s\n", s_name_and_ver_columns, full_feature_name, vcpkg::shorten_text(description, desc_length));
        }
    }

    constexpr StringLiteral OPTION_FULLDESC = "x-full-desc"; // TODO: This should find a better home, eventually

    constexpr std::array<CommandSwitch, 1> FindSwitches = {{{OPTION_FULLDESC, "Do not truncate long text"}}};

    const CommandStructure CveCheckCommandStructure = {
        Strings::format("Searches for the indicated artifact or port. With no parameter after 'artifact' or 'port', "
                        "displays everything.\n%s\n%s",
                        create_example_string("find port png"),
                        create_example_string("find artifact cmake")),
        1,
        1,
        {FindSwitches, {}},
        nullptr,
    };
}

namespace vcpkg::Commands
{
    ///*
    void perform_cve_check_port_and_exit(const VcpkgPaths& paths,
                                    bool full_description,
                                    bool enable_json,
                                    Optional<StringView> filter,
                                    View<std::string> overlay_ports)
    {

        HANDLE hAppend = CreateFile(TEXT("D:\\some_rep\\vcpkg\\_report.txt"),
                             GENERIC_WRITE,         // Open for writing
                             0,                     // Do not share
                             NULL,                  // No security
                             OPEN_ALWAYS,           // Open or create
                             FILE_ATTRIBUTE_NORMAL, // Normal file
                             NULL);                 // No template file

        if (hAppend == INVALID_HANDLE_VALUE)
        {
            return;
        }

        PathsPortFileProvider provider(paths, overlay_ports);
        auto source_paragraphs =
            Util::fmap(provider.load_all_control_files(),
                       [](auto&& port) -> const SourceControlFile* { return port->source_control_file.get(); });

        auto& fs = paths.get_filesystem();
        auto& download_manager = paths.get_download_manager();

        std::string sFolderDownloads = "D:\\some_rep\\vcpkg\\_cve_check\\";

        //if (auto* filter_str = filter.get())
        {
            //const auto contained_in = [filter_str](StringView haystack) {
            //    return Strings::case_insensitive_ascii_contains(haystack, *filter_str);
            //};

            std::string baseUrl =
                "https://services.nvd.nist.gov/rest/json/cpes/1.0?cpeMatchString=cpe:2.3:*:*:";

            std::string baseUrlCVE = "https://services.nvd.nist.gov/rest/json/cves/1.0?cpeMatchString=cpe:2.3:a:";

            for (const auto& source_control_file : source_paragraphs)
            {
                //source_control_file->parse_control_file();
                auto&& sp = *source_control_file->core_paragraph;

                // const auto* scfl = provider.get_control_file(port_name).get();

                std::string vend;
                std::string prod;
                std::string portFileName;
                std::string urlToDownload;
                auto resCF = provider.get_control_file(sp.name);
                const auto manifest_path = resCF.get()->source_location / "vcpkg.json";
                std::error_code ec;
                auto manifest_contents = fs.read_contents(manifest_path, ec);
                if (ec)
                {
                    continue;
                }
                else
                {
                    auto res = Json::parse(manifest_contents);
                    auto val = res.get();
                    if (val && val->first.is_object())
                    {
                        auto& valObj = val->first.object();
                        if (valObj.contains("cpe-info"))
                        {
                            auto* valCpe = valObj.get("cpe-info");
                            if (valCpe && valCpe->is_object())
                            {
                                auto& cpeObj = valCpe->object();
                                if (cpeObj.contains("vendor") && cpeObj.contains("product"))
                                {
                                    auto* vendorVal = cpeObj.get("vendor");
                                    auto* productVal = cpeObj.get("product");
                                    if (vendorVal && productVal)
                                    {
                                        vend = vendorVal->string().to_string();
                                        prod = productVal->string().to_string();

                                        urlToDownload = baseUrlCVE + vend + ':' + prod +
                                                          ':' + sp.raw_version;
                                    }
                                }
                            }
                        }
                    }
                }

                bool found = false;

                struct cve_info
                {
                    std::string CVE_ID;
                    std::string sVuln;
                    std::string sVerStartInc;
                    std::string sVerEndInc;
                    std::string sVerEndExcl;
                };
                
                std::vector<cve_info> cve_found;

                std::string downloadJson = sFolderDownloads + sp.name + ".json";
                download_manager.download_file(fs, urlToDownload, downloadJson, nullopt);

                auto parsed_json = Json::parse_file(VCPKG_LINE_INFO, fs, downloadJson);
                auto& mainJsonObj = parsed_json.first.object();
                auto resultNum = mainJsonObj.get("totalResults")->integer();

                if (resultNum == 0)
                {
                    continue;
                }
                else if (mainJsonObj.contains("result"))
                {


                    auto* resVal = mainJsonObj.get("result");
                    if (resVal->is_object())
                    {
                        auto& resObj = resVal->object();
                        if (resObj.contains("CVE_Items"))
                        {
                            auto* cpeVal = resObj.get("CVE_Items");
                            if (cpeVal->is_array())
                            {
                                auto& cpeList = cpeVal->array();
                                for (auto& cve: cpeList)
                                {
                                    auto& cveObj = cve.object();

                                    cve_info cveInfo;

                                    if (cveObj.contains("cve"))
                                    {
                                        auto* cveObjVal = cveObj.get("cve");
                                        if (cveObjVal && cveObjVal->is_object())
                                        {
                                            auto& cveIdObj = cveObjVal->object();
                                            if (cveIdObj.contains("CVE_data_meta"))
                                            {
                                                auto* cveDataMet = cveIdObj.get("CVE_data_meta");
                                                if (cveDataMet && cveDataMet->is_object())
                                                {
                                                    auto& cveDataMetObj = cveDataMet->object();
                                                    if (cveDataMetObj.contains("ID"))
                                                    {
                                                        cveInfo.CVE_ID = cveDataMetObj.get("ID")->string().to_string();
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    vcpkg::Json::Value* nodeVal = nullptr;
                                    if (cveObj.contains("configurations"))
                                    {
                                        auto* cveConf = cveObj.get("configurations");
                                        if (cveConf && cveConf->is_object())
                                        {
                                            auto& confObj = cveConf->object();
                                            if (confObj.contains("nodes"))
                                            {
                                                auto* nodes = confObj.get("nodes");
                                                if (nodes && nodes->is_array())
                                                {
                                                    auto& nodesList = nodes->array();
                                                    if (nodesList.size() > 0)
                                                    {
                                                        nodeVal = &nodesList[0];
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    if (nodeVal && nodeVal->is_object())
                                    {
                                        auto& nodeObj = nodeVal->object();
                                        if (nodeObj.contains("cpe_match"))
                                        {
                                            auto* cpeMatchVal = nodeObj.get("cpe_match");
                                            if (cpeMatchVal && cpeMatchVal->is_array())
                                            {
                                                auto& cpeArr = cpeMatchVal->array();
                                                if (cpeArr.size() > 0)
                                                {
                                                    auto& cveEntry = cpeArr[0];
                                                    if (cveEntry.is_object())
                                                    {
                                                        found = true;

                                                        auto& cveEntryObj = cveEntry.object();
                                                        if (cveEntryObj.contains("vulnerable"))
                                                        {
                                                            auto* vulnVal = cveEntryObj.get("vulnerable");
                                                            if (vulnVal && vulnVal->is_boolean())
                                                            {
                                                                cveInfo.sVuln += vulnVal->boolean() ? "true" : "false";
                                                            }
                                                        }

                                                        if (cveEntryObj.contains("versionStartIncluding"))
                                                        {
                                                            auto* verVal = cveEntryObj.get("versionStartIncluding");
                                                            if (verVal && verVal->is_string())
                                                            {
                                                                cveInfo.sVerStartInc += verVal->string().to_string();
                                                            }
                                                        }

                                                        if (cveEntryObj.contains("versionEndIncluding"))
                                                        {
                                                            auto* verVal = cveEntryObj.get("versionEndIncluding");
                                                            if (verVal && verVal->is_string())
                                                            {
                                                                cveInfo.sVerEndInc += verVal->string().to_string();
                                                            }
                                                        }

                                                        if (cveEntryObj.contains("versionEndExcluding"))
                                                        {
                                                            auto* verVal = cveEntryObj.get("versionEndExcluding");
                                                            if (verVal && verVal->is_string())
                                                            {
                                                                cveInfo.sVerEndExcl += verVal->string().to_string();
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (!found)
                {
                    continue;
                }

                std::string sRes = "=============> " + sp.name + '\n';
                for (auto& val : cve_found)
                {
                    sRes += "ID: " + val.CVE_ID + '\n';
                    sRes += "vulnerable: " + val.sVuln + '\n';
                    sRes += "versionStartIncluding: " + val.sVerStartInc + '\n';
                    sRes += "versionEndIncluding: " + val.sVerEndInc + '\n';
                    sRes += "versionEndExcluding: " + val.sVerEndExcl + '\n';
                }
                sRes += "======================\n\n";

                DWORD dwBytesWritten = 0;
                auto ret = WriteFile(hAppend, sRes.data(), sRes.size(), &dwBytesWritten, NULL);
                if (!ret)
                {
                    std::string ss = "123";
                }

                //bool found_match = contained_in(sp.name);
                //if (!found_match)
                //{
                //    found_match = std::any_of(sp.description.begin(), sp.description.end(), contained_in);
                //}
                //
                //if (found_match)
                //{
                //    do_print(sp, full_description);
                //}

                //for (auto&& feature_paragraph : source_control_file->feature_paragraphs)
                //{
                    //bool found_match_for_feature = found_match;
                    //if (!found_match_for_feature)
                    //{
                    //    found_match_for_feature = contained_in(feature_paragraph->name);
                    //}
                    //if (!found_match_for_feature)
                    //{
                    //    found_match_for_feature = std::any_of(
                    //        feature_paragraph->description.begin(), feature_paragraph->description.end(), contained_in);
                    //}
                    //
                    //if (found_match_for_feature)
                    //{
                    //    do_print(sp.name, *feature_paragraph, full_description);
                    //}
                //}
            }
        }
        //else
        //{
        //    if (enable_json)
        //    {
        //        do_print_json(source_paragraphs);
        //    }
        //    else
        //    {
        //        for (const auto& source_control_file : source_paragraphs)
        //        {
        //            do_print(*source_control_file->core_paragraph, full_description);
        //            for (auto&& feature_paragraph : source_control_file->feature_paragraphs)
        //            {
        //                do_print(source_control_file->core_paragraph->name, *feature_paragraph, full_description);
        //            }
        //        }
        //    }
        //}

        if (!enable_json)
        {
            print2("The result may be outdated. Run `git pull` to get the latest results.\n"
                   "\nIf your port is not listed, please open an issue at and/or consider making a pull request:\n"
                   "    https://github.com/Microsoft/vcpkg/issues\n");
        }

        Checks::exit_success(VCPKG_LINE_INFO);
    }

    void perform_cve_check_artifact_and_exit(const VcpkgPaths& paths, Optional<StringView> filter)
    {
        std::vector<std::string> ce_args;
        ce_args.push_back("find");
        if (auto* filter_str = filter.get())
        {
            ce_args.emplace_back(filter_str->data(), filter_str->size());
        }
    
        Checks::exit_with_code(VCPKG_LINE_INFO, run_configure_environment_command(paths, ce_args));
    }
    //*/

    void CveCheckCommand::perform_and_exit(const VcpkgCmdArguments& args, const VcpkgPaths& paths) const
    {
        const ParsedArguments options = args.parse_arguments(CveCheckCommandStructure);
        const bool full_description = Util::Sets::contains(options.switches, OPTION_FULLDESC);
        const bool enable_json = args.json.value_or(false);
        auto&& selector = args.command_arguments[0];
        Optional<StringView> filter;
        if (args.command_arguments.size() == 2)
        {
            filter = StringView{args.command_arguments[1]};
        }

        //if (selector == "artifact")
        //{
        //    if (full_description)
        //    {
        //        print2(Color::warning, "--%s has no effect on find artifact\n", OPTION_FULLDESC);
        //    }
        //
        //    if (enable_json)
        //    {
        //        print2(Color::warning, "--x-json has no effect on find artifact\n");
        //    }
        //
        //    perform_cve_check_artifact_and_exit(paths, filter);
        //}

        if (selector == "ports")
        {
            perform_cve_check_port_and_exit(paths, full_description, enable_json, filter, args.overlay_ports);
        }

        Checks::exit_with_message(VCPKG_LINE_INFO, "The first parmaeter to add must be 'artifact' or 'port'.\n");
    }
}
